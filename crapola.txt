advance.c:	    FTYPE (*pl_ct)[N1M][N2M][N3M][NPR2INTERP], FTYPE (*pr_ct)[N1M][N2M][N3M][NPR2INTERP],
advance.c:		       FTYPE (*pl_ct)[N1M][N2M][N3M][NPR2INTERP], FTYPE (*pr_ct)[N1M][N2M][N3M][NPR2INTERP],
advance.c:			   FTYPE (*pl_ct)[N1M][N2M][N3M][NPR2INTERP], FTYPE (*pr_ct)[N1M][N2M][N3M][NPR2INTERP],
advance.c:		     FTYPE (*pl_ct)[N1M][N2M][N3M][NPR2INTERP], FTYPE (*pr_ct)[N1M][N2M][N3M][NPR2INTERP],
advance.c:    MYFUN(fluxcalc(stage,pb,pstag,pl_ct, pr_ct, vpot,F1,F2,F3,CUf[2],fluxdt,&ndt1,&ndt2,&ndt3),"advance.c:advance_standard()", "fluxcalcall", 1);
advance.c:			 FTYPE (*pl_ct)[N1M][N2M][N3M][NPR2INTERP], FTYPE (*pr_ct)[N1M][N2M][N3M][NPR2INTERP],
advance.c:    MYFUN(fluxcalc(stage,pb,pstag,pl_ct, pr_ct, vpot,F1,F2,F3,CUf[2],fluxdt,&ndt1,&ndt2,&ndt3),"advance.c:advance_standard()", "fluxcalcall", 1);
flux.c:	     FTYPE (*pl_ct)[N1M][N2M][N3M][NPR2INTERP], FTYPE (*pr_ct)[N1M][N2M][N3M][NPR2INTERP],
flux.c:  int fluxcalc_flux(int stage, FTYPE pr[][N2M][N3M][NPR], FTYPE pstag[][N2M][N3M][NPR], FTYPE (*pl_ct)[N1M][N2M][N3M][NPR2INTERP], FTYPE (*pr_ct)[N1M][N2M][N3M][NPR2INTERP], int *Nvec, FTYPE (*dqvec[NDIM])[N2M][N3M][NPR2INTERP], FTYPE (*fluxvec[NDIM])[N2M][N3M][NPR], FTYPE (*fluxvecEM[NDIM])[N2M][N3M][NPR], FTYPE CUf, FTYPE *ndtvec[NDIM], struct of_loop *cent2faceloop);
flux.c:  int fluxcalc_fluxctstag(int stage, FTYPE pr[][N2M][N3M][NPR], FTYPE pstag[][N2M][N3M][NPR], FTYPE (*pl_ct)[N1M][N2M][N3M][NPR2INTERP], FTYPE (*pr_ct)[N1M][N2M][N3M][NPR2INTERP], int *Nvec, FTYPE (*dqvec[NDIM])[N2M][N3M][NPR2INTERP], FTYPE (*fluxvec[NDIM])[N2M][N3M][NPR], FTYPE CUf, struct of_loop *cent2faceloop, struct of_loop (*face2cornloop)[NDIM][NDIM]);
flux.c:  // Final p_l p_r results of interpolation are stored in pl_ct pr_ct if needed by SPLITNPR or FLUXB==FLUXCTSTAG
flux.c:  fluxcalc_flux(stage, pr, pstag, pl_ct, pr_ct, Nvec, dqvec, fluxvec, fluxvecEM, CUf, ndtvec, cent2faceloop);
flux.c:  // assumes fluxcalc_flux() above called fluxcalc_standard_4fluxctstag() so pl_ct and pr_ct are set with FACE1,2,3 values of all quantities (including field along dir that comes from pstagscratch[] in this case)
flux.c:    MYFUN(fluxcalc_fluxctstag(stage, pr, pstag, pl_ct, pr_ct, Nvec, dqvec, ptrfluxvec, CUf, cent2faceloop, face2cornloop),"flux.c:fluxcalc()", "fluxcalc_fluxctstag", 0);
flux.c:int fluxcalc_flux(int stage, FTYPE pr[][N2M][N3M][NPR], FTYPE pstag[][N2M][N3M][NPR], FTYPE (*pl_ct)[N1M][N2M][N3M][NPR2INTERP], FTYPE (*pr_ct)[N1M][N2M][N3M][NPR2INTERP], int *Nvec, FTYPE (*dqvec[NDIM])[N2M][N3M][NPR2INTERP], FTYPE (*fluxvec[NDIM])[N2M][N3M][NPR], FTYPE (*fluxvecEM[NDIM])[N2M][N3M][NPR], FTYPE CUf, FTYPE *ndtvec[NDIM], struct of_loop *cent2faceloop)
flux.c:    MYFUN(fluxcalc_flux_1d(stage, pr, pstag, pl_ct, pr_ct, dir, is, ie, js, je, ks, ke, idel, jdel, kdel, face, dqvec[dir], fluxvec[dir], fluxvecEM[dir], CUf, ndtvec[dir], &cent2faceloop[dir], &didassigngetstatecentdata),"flux.c:fluxcalc()", "fluxcalc_flux_1d", dir);
flux.c:int fluxcalc_flux_1d(int stage, FTYPE pr[][N2M][N3M][NPR], FTYPE pstag[][N2M][N3M][NPR], FTYPE (*pl_ct)[N1M][N2M][N3M][NPR2INTERP], FTYPE (*pr_ct)[N1M][N2M][N3M][NPR2INTERP], int dir, int is, int ie, int js, int je, int ks, int ke, int idel, int jdel, int kdel, int face, FTYPE (*dq)[N2M][N3M][NPR2INTERP], FTYPE F[][N2M][N3M][NPR], FTYPE FEM[][N2M][N3M][NPR], FTYPE CUf, FTYPE *ndt, struct of_loop *cent2faceloop, int *didassigngetstatecentdata )
flux.c:  int fluxcalc_standard(int stage, FTYPE pr[][N2M][N3M][NPR], FTYPE pstag[][N2M][N3M][NPR], FTYPE (*pl_ct)[N1M][N2M][N3M][NPR2INTERP], FTYPE (*pr_ct)[N1M][N2M][N3M][NPR2INTERP], int dir, int is, int ie, int js, int je, int ks, int ke, int idel, int jdel, int kdel, int face, FTYPE (*dq)[N2M][N3M][NPR2INTERP], FTYPE F[][N2M][N3M][NPR], FTYPE FEM[][N2M][N3M][NPR], FTYPE CUf, FTYPE *ndt, struct of_loop *cent2faceloop, int *didassigngetstatecentdata);
flux.c:  int fluxcalc_standard_4fluxctstag(int stage, FTYPE pr[][N2M][N3M][NPR], FTYPE pstag[][N2M][N3M][NPR], FTYPE (*pl_ct)[N1M][N2M][N3M][NPR2INTERP], FTYPE (*pr_ct)[N1M][N2M][N3M][NPR2INTERP], int dir, int is, int ie, int js, int je, int ks, int ke, int idel, int jdel, int kdel, int face, FTYPE (*dq)[N2M][N3M][NPR2INTERP], FTYPE F[][N2M][N3M][NPR], FTYPE FEM[][N2M][N3M][NPR], FTYPE CUf, FTYPE *ndt, struct of_loop *cent2faceloop, int *didassigngetstatecentdata);
flux.c:      MYFUN(fluxcalc_standard_4fluxctstag(stage,pr,pstag,pl_ct, pr_ct, dir,is, ie, js, je, ks, ke,idel,jdel,kdel,face,dq,F,FEM,CUf,ndt,cent2faceloop,didassigngetstatecentdata),"flux.c:fluxcalc_flux_1d()", "fluxcalc_standard_4fluxctstag()", 1);
flux.c:      // use older code that doesn't store into pl_ct and pr_ct since not needed and then waste of memory
flux.c:      MYFUN(fluxcalc_standard(stage,pr,pstag,pl_ct, pr_ct, dir,is, ie, js, je, ks, ke,idel,jdel,kdel,face,dq,F,FEM,CUf,ndt,cent2faceloop,didassigngetstatecentdata),"flux.c:fluxcalc_flux_1d()", "fluxcalc_standard()", 1);
flux.c:int fluxcalc_standard(int stage, FTYPE pr[][N2M][N3M][NPR], FTYPE pstag[][N2M][N3M][NPR], FTYPE (*pl_ct)[N1M][N2M][N3M][NPR2INTERP], FTYPE (*pr_ct)[N1M][N2M][N3M][NPR2INTERP], int dir, int is, int ie, int js, int je, int ks, int ke, int idel, int jdel, int kdel, int face, FTYPE (*dq)[N2M][N3M][NPR2INTERP], FTYPE F[][N2M][N3M][NPR], FTYPE FEM[][N2M][N3M][NPR], FTYPE CUf, FTYPE *ndt, struct of_loop *cent2faceloop, int *didassigngetstatecentdata)
flux.c:// For example, to keep algorithm simple, always assume all directions of pl_ct and pr_ct exist, but if doing 2D simulation then we don't fill "left-right" states, so instead we need to compute or assign it so that data exists
flux.c:void do_noninterpolation_dimension(int whichfluxcalc, int dointerpolation,  int realisinterp, int dir, int idel, int jdel, int kdel, FTYPE (*pr)[N2M][N3M][NPR], FTYPE (*pl_ct)[N1M][N2M][N3M][NPR2INTERP], FTYPE (*pr_ct)[N1M][N2M][N3M][NPR2INTERP], struct of_loop *cent2faceloop, int *didassigngetstatecentdata)
flux.c:  // if storing pl_ct and pr_ct, then copy 1D result in case used in some way not associated with whether dimension exists or not (not expensive)
flux.c:  COMPFULLLOOP PLOOPINTERP(pl) pl_ct[dir][i][j][k][pl]=pr_ct[dir][i][j][k][pl]=pr[i][j][k][pl];
flux.c:// set pl_ct and pr_ct with FACE interpolations from CENT (including field face from pstagscratch[])
flux.c:int fluxcalc_standard_4fluxctstag(int stage, FTYPE pr[][N2M][N3M][NPR], FTYPE pstag[][N2M][N3M][NPR], FTYPE (*pl_ct)[N1M][N2M][N3M][NPR2INTERP], FTYPE (*pr_ct)[N1M][N2M][N3M][NPR2INTERP], int dir, int is, int ie, int js, int je, int ks, int ke, int idel, int jdel, int kdel, int face, FTYPE (*dq)[N2M][N3M][NPR2INTERP], FTYPE F[][N2M][N3M][NPR], FTYPE FEM[][N2M][N3M][NPR], FTYPE CUf, FTYPE *ndt, struct of_loop *cent2faceloop, int *didassigngetstatecentdata)
flux.c:  // obtain pl_ct and pr_ct (point face quantities) from pr (point centered quantity)
flux.c:  interpolate_prim_cent2face(stage, realisinterp, pr, pstag, pl_ct, pr_ct, dir, is, ie, js, je, ks, ke, idel, jdel, kdel, face, dq, cent2faceloop);
flux.c:      MYFUN(flux_compute_general(i, j, k, dir, &geom, CUf,  pr[i][j][k], pl_ct[dir][i][j][k], pr_ct[dir][i][j][k], F[i][j][k], &ctop),"step_ch.c:fluxcalc()", "flux_compute", 1);
flux.c:      MYFUN(flux_compute_splitmaem(i, j, k, dir, &geom, CUf,  pr[i][j][k], pl_ct[dir][i][j][k], pr_ct[dir][i][j][k], F[i][j][k], FEM[i][j][k], &ctop),"step_ch.c:fluxcalc()", "flux_compute", 1);
flux.c:// sets global variables pl_ct and pr_ct to p_l and p_r from interpolations
flux.c:    // don't really need fluxes in this domain, but do need interpolated face values to be transferred from pleft/pright to pl_ct pr_ct
flux.c:    // If doing staggered field method, then also assumes left,right stored like pl_ct and pr_ct are stored
fluxctstag.c:int fluxcalc_fluxctstag(int stage, FTYPE pr[][N2M][N3M][NPR], FTYPE pstag[][N2M][N3M][NPR], FTYPE (*pl_ct)[N1M][N2M][N3M][NPR2INTERP], FTYPE (*pr_ct)[N1M][N2M][N3M][NPR2INTERP], int *Nvec, FTYPE (*dqvec[NDIM])[N2M][N3M][NPR2INTERP], FTYPE (*fluxvec[NDIM])[N2M][N3M][NPR], FTYPE CUf, struct of_loop *cent2faceloop, struct of_loop (*face2cornloop)[NDIM][NDIM])
fluxctstag.c:  // first obtain pbinterp and pvinterp (point CORN1,2,3 quantities) from pl_ct and pr_ct (FACE1,2,3 quantities)
fluxctstag.c:  interpolate_prim_face2corn(pr, pl_ct, pr_ct, pbcorninterp, pvcorninterp, cent2faceloop, face2cornloop);
flux.mergedc2ea2cmethod.c:// 1) Worry about boundary edges and that don't store entire cell interpolation at very edges where only previously needed flux at face.  Might need to store more p_l, p_r, pl_ct, pr_ct, and state info
step_ch.c:int step_ch_full(FTYPE prim[][N2M][N3M][NPR], FTYPE pstag[][N2M][N3M][NPR], FTYPE ucons[][N2M][N3M][NPR], FTYPE (*vpot)[N1M+SHIFT1][N2M+SHIFT2][N3M+SHIFT3], FTYPE Bhat[][N2M][N3M][NPR], FTYPE (*pl_ct)[N1M][N2M][N3M][NPR2INTERP], FTYPE (*pr_ct)[N1M][N2M][N3M][NPR2INTERP])
step_ch.c:  step_ch(dumpingnext, &fullndt,prim,pstag,ucons,vpot,Bhat,pl_ct, pr_ct);
step_ch.c:int step_ch(int *dumpingnext, FTYPE *fullndt,FTYPE prim[][N2M][N3M][NPR], FTYPE pstag[][N2M][N3M][NPR], FTYPE ucons[][N2M][N3M][NPR], FTYPE (*vpot)[N1M+SHIFT1][N2M+SHIFT2][N3M+SHIFT3], FTYPE Bhat[][N2M][N3M][NPR], FTYPE (*pl_ct)[N1M][N2M][N3M][NPR2INTERP], FTYPE (*pr_ct)[N1M][N2M][N3M][NPR2INTERP])
step_ch.c:  int step_ch_simplempi(int *dumpingnext, FTYPE *fullndt,FTYPE prim[][N2M][N3M][NPR], FTYPE pstag[][N2M][N3M][NPR], FTYPE ucons[][N2M][N3M][NPR], FTYPE (*vpot)[N1M+SHIFT1][N2M+SHIFT2][N3M+SHIFT3], FTYPE Bhat[][N2M][N3M][NPR], FTYPE (*pl_ct)[N1M][N2M][N3M][NPR2INTERP], FTYPE (*pr_ct)[N1M][N2M][N3M][NPR2INTERP]);
step_ch.c:  int step_ch_supermpi(int *dumpingnext, FTYPE *fullndt,FTYPE prim[][N2M][N3M][NPR], FTYPE pstag[][N2M][N3M][NPR], FTYPE ucons[][N2M][N3M][NPR], FTYPE (*vpot)[N1M+SHIFT1][N2M+SHIFT2][N3M+SHIFT3], FTYPE Bhat[][N2M][N3M][NPR], FTYPE (*pl_ct)[N1M][N2M][N3M][NPR2INTERP], FTYPE (*pr_ct)[N1M][N2M][N3M][NPR2INTERP]);
step_ch.c:  MYFUN(step_ch_simplempi(dumpingnext, fullndt,prim,pstag,ucons,vpot,Bhat,pl_ct, pr_ct),"step_ch.c:step_ch()", "step_ch_simplempi()", 1);
step_ch.c:  MYFUN(step_ch_supermpi(dumpingnext, fullndt,prim,pstag,ucons,vpot,Bhat,pl_ct, pr_ct),"step_ch.c:step_ch()", "step_ch_supermpi()", 1);
step_ch.c:int step_ch_simplempi(int *dumpingnext, FTYPE *fullndt, FTYPE prim[][N2M][N3M][NPR], FTYPE pstag[][N2M][N3M][NPR], FTYPE ucons[][N2M][N3M][NPR], FTYPE (*vpot)[N1M+SHIFT1][N2M+SHIFT2][N3M+SHIFT3], FTYPE Bhat[][N2M][N3M][NPR], FTYPE (*pl_ct)[N1M][N2M][N3M][NPR2INTERP], FTYPE (*pr_ct)[N1M][N2M][N3M][NPR2INTERP])
step_ch.c:      MYFUN(advance(STAGEM1, pii[timeorder], pbb[timeorder], pff[timeorder], pstag, pl_ct, pr_ct, vpot, uii[timeorder], uff[timeorder], ucum[timeorder], CUf[timeorder], Cunew[timeorder], fluxdt[timeorder], boundtime[timeorder], timeorder,numtimeorders,&ndt),"step_ch.c:step_ch_simplempi()", "advance()", 1);
step_ch.c:      MYFUN(advance(STAGEM1, pii[timeorder], pbb[timeorder], pff[timeorder], pstag, pl_ct, pr_ct, vpot, uii[timeorder], uff[timeorder], ucum[timeorder], CUf[timeorder], Cunew[timeorder], fluxdt[timeorder], boundtime[timeorder], timeorder,numtimeorders,&ndt),"step_ch.c:step_ch_simplempi()", "advance()", 1);
step_ch.c:      MYFUN(advance(STAGEM1, pii[timeorder], pbb[timeorder], pff[timeorder], pstag, pl_ct, pr_ct, vpot, uii[timeorder], uff[timeorder], ucum[timeorder], CUf[timeorder], Cunew[timeorder], fluxdt[timeorder], boundtime[timeorder], timeorder,numtimeorders,&ndt),"step_ch.c:step_ch_simplempi()", "advance()", 1);
step_ch.c:int step_ch_supermpi(int *dumpingnext, FTYPE *fullndt, FTYPE prim[][N2M][N3M][NPR], FTYPE pstag[][N2M][N3M][NPR], FTYPE ucons[][N2M][N3M][NPR], FTYPE (*vpot)[N1M+SHIFT1][N2M+SHIFT2][N3M+SHIFT3], FTYPE Bhat[][N2M][N3M][NPR], FTYPE (*pl_ct)[N1M][N2M][N3M][NPR2INTERP], FTYPE (*pr_ct)[N1M][N2M][N3M][NPR2INTERP])
step_ch.c:      MYFUN(advance(-1, pii[timeorder], pbb[timeorder], pff[timeorder], pstag, pl_ct, pr_ct, vpot, uii[timeorder], uff[timeorder], ucum[timeorder],CUf[timeorder], Cunew[timeorder], fluxdt[timeorder], boundtime[timeorder], timeorder,numtimeorders,&ndt),"step_ch.c:step_ch_supermpi()", "advance()", 1);
